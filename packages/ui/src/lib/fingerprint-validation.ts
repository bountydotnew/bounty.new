// Define the thumbmarkResponse interface based on the library's structure
export interface thumbmarkResponse {
  components: Record<string, unknown>;
  info: {
    [key: string]: unknown;
  };
  version: string;
  thumbmark: string;
  elapsed?: number; // Optional property that may be present if options.performance is true
}

// Validate that the components object has a reasonable structure
export function validateFingerprintStructure(components: unknown): boolean {
  try {
    // Check that components is an object
    if (!components || typeof components !== 'object') {
      return false;
    }

    const comp = components as Record<string, unknown>;

    // Check that we have at least some components (thumbmark.js structure)
    const componentCount = Object.keys(comp).length;
    if (componentCount < 1) {
      return false;
    }

    // For thumbmark.js, we'll be more flexible about which components exist
    // Just check that we have some reasonable data structure
    let hasValidComponent = false;

    // Check for any common components that might exist
    const possibleComponents = [
      'audio',
      'canvas',
      'screen',
      'system',
      'webgl',
      'fonts',
    ];
    for (const componentName of possibleComponents) {
      if (comp[componentName] && typeof comp[componentName] === 'object') {
        hasValidComponent = true;
        break;
      }
    }

    return hasValidComponent;
  } catch {
    return false;
  }
}

// Generate a hash from fingerprint components to verify integrity
export function generateFingerprintHash(): string {
  // For now, we'll disable hash verification since thumbmark.js generates its own hash
  // The thumbmark hash is generated by the library itself and we can't recreate it
  return 'skip_hash_validation';
}

// Validate that the provided hash matches the components
export function validateFingerprintHash(providedHash: string): boolean {
  // For now, we'll skip hash validation since thumbmark.js uses its own algorithm
  // We'll rely on structure validation instead
  return !!(
    providedHash &&
    typeof providedHash === 'string' &&
    providedHash.length > 0
  );
}

// Check if fingerprint looks realistic (not obviously fake)
export function validateFingerprintRealism(
  components: Record<string, unknown>
): boolean {
  // For thumbmark.js, we'll be more permissive since it generates its own structure
  // We'll only check for obviously fake or missing critical components

  // Check if we have some basic components
  const componentKeys = Object.keys(components);
  if (componentKeys.length < 2) {
    return false; // Should have at least a few components
  }

  // Validate screen component
  if (!validateScreenComponent(components.screen)) {
    return false;
  }

  // Validate system/navigator component
  if (!validateSystemComponent(components.system)) {
    return false;
  }

  // For thumbmark.js, we'll trust the library's fingerprinting
  // and only reject obviously manipulated data
  return true;
}

// Helper: Validate screen component properties
function validateScreenComponent(screen: unknown): boolean {
  if (!screen || typeof screen !== 'object') {
    return true; // Optional component
  }

  const screenObj = screen as Record<string, unknown>;
  const colorDepth = screenObj.colorDepth as number | undefined;

  if (typeof colorDepth !== 'number') {
    return true; // Optional property
  }

  // Be more permissive with color depth - allow more values
  return colorDepth >= 1 && colorDepth <= 48;
}

// Helper: Validate system component properties
function validateSystemComponent(system: unknown): boolean {
  if (!system || typeof system !== 'object') {
    return true; // Optional component
  }

  const systemObj = system as Record<string, unknown>;

  // Check userAgent if present
  const userAgent = systemObj.useragent as string | undefined;
  if (typeof userAgent === 'string' && userAgent.length < 10) {
    return false;
  }

  // Check hardware concurrency if present
  const hardwareConcurrency = systemObj.hardwareConcurrency as
    | number
    | undefined;
  if (
    typeof hardwareConcurrency === 'number' &&
    (hardwareConcurrency < 1 || hardwareConcurrency > 128)
  ) {
    return false;
  }

  return true;
}

// Validation result interface
export interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

// Main validation function
export function validateFingerprint(
  fingerprintData: unknown
): ValidationResult {
  const errors: string[] = [];

  if (!fingerprintData) {
    errors.push('No fingerprint data provided');
    return { isValid: false, errors };
  }

  // Type guard to check if fingerprintData is a valid thumbmarkResponse
  if (typeof fingerprintData !== 'object' || fingerprintData === null) {
    errors.push('Invalid fingerprint data format');
    return { isValid: false, errors };
  }

  const data = fingerprintData as Record<string, unknown>;

  if (!data.components) {
    errors.push('No components in fingerprint data');
    return { isValid: false, errors };
  }

  if (!data.thumbmark || typeof data.thumbmark !== 'string') {
    errors.push('No thumbmark hash provided');
    return { isValid: false, errors };
  }

  // Validate structure
  if (!validateFingerprintStructure(data.components)) {
    errors.push('Invalid fingerprint structure');
    return { isValid: false, errors };
  }

  // Get components for further validation
  const components = data.components as Record<string, unknown>;

  if (!validateFingerprintHash(data.thumbmark as string)) {
    errors.push('Fingerprint hash validation failed');
  }

  if (!validateFingerprintRealism(components)) {
    errors.push('Fingerprint appears to be fake or unrealistic');
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}
